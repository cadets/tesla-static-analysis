#include "Debug.h"
#include "ModelGenerator.h"

#include <llvm/Support/raw_ostream.h>

using llvm::errs;

set<ModelGenerator::Model> ModelGenerator::ofLength(size_t length) {
  return fromExpression(Expr, length);
}

set<ModelGenerator::Model> ModelGenerator::fromExpression(const Expression &ex, size_t length) {
  switch(ex.type()) {
    case Expression_Type_BOOLEAN_EXPR:
      return fromBoolean(ex.booleanexpr(), length);

    case Expression_Type_SEQUENCE:
      return fromSequence(ex.sequence(), length);

    case Expression_Type_NULL_EXPR:
      return {{}};

    case Expression_Type_ASSERTION_SITE:
      return fromAssertionSite(ex.assertsite(), length);

    case Expression_Type_FUNCTION:
      return fromFunction(ex.function(), length);

    case Expression_Type_FIELD_ASSIGN:
      return fromFieldAssign(ex.fieldassign(), length);

    case Expression_Type_SUB_AUTOMATON:
      auto sub = Man->FindAutomaton(ex.subautomaton());
      return fromSubAutomaton(*sub, length);
  }
}

/**
 * What do we need to do here? We can generate every possible model from the
 * subexpressions of this sequence, and we need to combine them into a sequenced
 * model with an appropriate length.
 *
 * Could implement a variant that takes a length parameter and goes recursively.
 * If we can take a model of length n at the start and length - n at the end,
 * then concatenate them and return.
 */
set<ModelGenerator::Model> ModelGenerator::fromSequence(const Sequence &ex, size_t length) {
  return fromSequence(ex, length, 0);
}

set<ModelGenerator::Model> ModelGenerator::fromSequence(const Sequence &ex, size_t length, size_t index) {
  if(length == 0) {
    return {};
  }

  if(index >= ex.expression_size()) {
    return {{}};
  }

  auto head = ex.expression(index);

  auto hes = fromExpression(head, length);

  auto tes = fromSequence(ex, length, index+1);

  set<ModelGenerator::Model> ret;

  for(auto he : hes) {
    for(auto te : tes) {
      ModelGenerator::Model cat;
      for(auto hev : he) {
        cat.push_back(hev);
      }

      for(auto tev : te) {
        cat.push_back(tev);
      }

      if(cat.size() <= length) {
        ret.insert(cat);
      }
    }
  }

  return ret;
}

/**
 * The only boolean expression we care about is inclusive OR - any model
 * generated by one of its subexpressions is valid, as long as the length
 * restriction is maintained.
 */
set<ModelGenerator::Model> ModelGenerator::fromBoolean(const BooleanExpr &ex, size_t length) {
  assert(ex.operation() == BooleanExpr_Operation_BE_Xor);

  set<ModelGenerator::Model> possibles;
  for(int i = 0; i < ex.expression_size(); i++) {
    auto disj = fromExpression(ex.expression(i), length);
    std::copy(disj.begin(), disj.end(), std::inserter(possibles, possibles.begin()));
  }

  return possibles;
}

/**
 * An assertion site event can only generate one possible assertion (itself).
 */
set<ModelGenerator::Model> ModelGenerator::fromAssertionSite(const AssertionSite &ex, size_t length) {
  if(length == 0) {
    return {};
  }

  auto expr = new Expression;
  expr->set_type(Expression_Type_ASSERTION_SITE);
  *expr->mutable_assertsite() = ex;
  return {{expr}};
}

/**
 * A function event can only generate one possible assertion (itself).
 */
set<ModelGenerator::Model> ModelGenerator::fromFunction(const FunctionEvent &ex, size_t length) {
  if(length == 0) {
    return {};
  }

  auto expr = new Expression;
  expr->set_type(Expression_Type_FUNCTION);
  *expr->mutable_function() = ex;
  return {{expr}};
}

/**
 * Needs to return a field assignment event rather than just the empty set
 * because we cannot check field assignment events at all - so we need to mark
 * that by having the event in the generated model.
 */
set<ModelGenerator::Model> ModelGenerator::fromFieldAssign(const FieldAssignment &ex, size_t length) {
  if(length == 0) {
    return {};
  }

  auto expr = new Expression;
  expr->set_type(Expression_Type_FIELD_ASSIGN);
  *expr->mutable_fieldassign() = ex;
  return {{expr}};
}

/**
 * Just recurse directly into the named subautomaton.
 */
set<ModelGenerator::Model> ModelGenerator::fromSubAutomaton(const Automaton &ex, size_t length) {
  return fromExpression(ex.getAssertion().expression(), length);
}
